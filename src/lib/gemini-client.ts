
// ================================================================
// GEMINI API CLIENT - Production Gemini Integration
// ================================================================
// Direct integration with Google Gemini API for production use

import { ModelTier, GeminiConfig, GeminiResponse, GeminiError } from './ai-model-types';
import { getErrorMessage, isGeminiErrorResponse } from './types/type-guards';

/**
 * Real Gemini API Client for production use
 * Supports all Gemini model tiers with proper error handling and rate limiting
 */
export class GeminiClient {
  private readonly apiKey: string;
  // Use v1 instead of v1beta - v1beta is deprecated and missing newer models
  private readonly baseUrl = 'https://generativelanguage.googleapis.com/v1';

  // Rate limiting
  private requestCounts: Map<string, number> = new Map();
  private resetTimes: Map<string, number> = new Map();

  // Model mappings to Google API model names
  private readonly modelMappings: Record<ModelTier, string> = {
    [ModelTier.LITE]: 'gemini-2.5-flash-lite',
    [ModelTier.BALANCED]: 'gemini-2.5-flash',
    [ModelTier.PRO]: 'gemini-2.5-pro'
  };

  // Rate limits per model (requests per minute)
  private readonly rateLimits: Record<ModelTier, number> = {
    [ModelTier.LITE]: 1000,
    [ModelTier.BALANCED]: 500,
    [ModelTier.PRO]: 100
  };

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('Google API Key is required for Gemini client');
    }
    this.apiKey = apiKey;
  }

  /**
   * Generate content using Gemini API with the specified configuration
   */
  async generateContent(
    prompt: string,
    config: Partial<GeminiConfig> = {}
  ): Promise<GeminiResponse> {
    const finalConfig: GeminiConfig = {
      apiKey: this.apiKey,
      model: config.model || ModelTier.BALANCED,
      maxTokens: config.maxTokens || 3000,
      temperature: config.temperature || 0.1,
      topP: config.topP || 0.95,
      topK: Math.min(config.topK || 40, 40), // Ensure topK never exceeds 40
      ...config
    };

    // Force topK to be within valid range after spread
    finalConfig.topK = Math.min(finalConfig.topK || 40, 40);

    await this.checkRateLimit(finalConfig.model);

    const modelName = this.modelMappings[finalConfig.model];
    // API v1 endpoint format: /v1/models/{model}:generateContent?key={apiKey}
    const url = `${this.baseUrl}/models/${modelName}:generateContent?key=${this.apiKey}`;

    const requestBody = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: finalConfig.temperature,
        topK: finalConfig.topK,
        topP: finalConfig.topP,
        maxOutputTokens: finalConfig.maxTokens
        // Note: responseMimeType was removed in v1 API (was v1beta only)
        // For JSON output in v1, use response_schema instead if needed
      },
      safetySettings: [
        {
          category: 'HARM_CATEGORY_HARASSMENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          category: 'HARM_CATEGORY_HATE_SPEECH',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE'
        }
      ]
    };

    try {
      console.log(`ü§ñ Calling Gemini API: ${modelName}`);

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw this.createGeminiError(response.status, errorData);
      }

      const data = await response.json();

      // Extract content from Gemini response
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

      if (!content) {
        throw new Error('No content generated by Gemini');
      }

      // Calculate token usage (estimation for now)
      const promptTokens = this.estimateTokens(prompt);
      const completionTokens = this.estimateTokens(content);

      this.updateRateLimit(finalConfig.model);

      return {
        content,
        usage: {
          promptTokens,
          completionTokens,
          totalTokens: promptTokens + completionTokens
        },
        model: modelName,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error(`‚ùå Gemini API error:`, error);

      if (error instanceof Error && error.message.includes('rate limit')) {
        throw this.createGeminiError(429, {
          error: 'Rate limit exceeded',
          details: `Rate limit for ${finalConfig.model} exceeded. Try again later.`
        });
      }

      throw error;
    }
  }

  /**
   * Generate JSON content specifically for structured analysis
   */
  async generateJsonContent(
    prompt: string,
    config: Partial<GeminiConfig> = {}
  ): Promise<unknown> {
    // Add JSON instruction to prompt
    const jsonPrompt = `${prompt}

IMPORTANT: Return your response in valid JSON format only. Do not include unknown text before or after the JSON.`;

    const response = await this.generateContent(jsonPrompt, {
      ...config,
      temperature: config.temperature || 0.1 // Lower temperature for JSON
    });

    try {
      const jsonContent = this.extractJsonFromResponse(response.content);
      return JSON.parse(jsonContent);
    } catch (error) {
      const errorMsg = getErrorMessage(error);
      console.error('Failed to parse JSON response from Gemini:', errorMsg);
      console.error('Raw response:', response.content);
      throw new Error('Failed to parse JSON response from Gemini API');
    }
  }

  /**
   * Extract JSON from Gemini response that may contain markdown or extra text
   */
  private extractJsonFromResponse(content: string): string {
    // Try to find JSON block in markdown
    const jsonBlockMatch = content.match(/```(?:json)?\s*\n?([\s\S]*?)\n?```/i);
    if (jsonBlockMatch) {
      return jsonBlockMatch[1].trim();
    }

    // Try to find JSON object
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return jsonMatch[0];
    }

    // Return as-is if no special formatting detected
    return content.trim();
  }

  /**
   * Check rate limits before making request
   */
  private async checkRateLimit(model: ModelTier): Promise<void> {
    const currentTime = Date.now();
    const resetTime = this.resetTimes.get(model) || 0;
    const requestCount = this.requestCounts.get(model) || 0;
    const limit = this.rateLimits[model];

    // Reset counter if minute has passed
    if (currentTime >= resetTime) {
      this.requestCounts.set(model, 0);
      this.resetTimes.set(model, currentTime + 60000); // Next minute
      return;
    }

    // Check if we've exceeded the limit
    if (requestCount >= limit) {
      const waitTime = resetTime - currentTime;
      throw new Error(`Rate limit exceeded for ${model}. Wait ${Math.ceil(waitTime / 1000)} seconds.`);
    }
  }

  /**
   * Update rate limit counter after successful request
   */
  private updateRateLimit(model: ModelTier): void {
    const currentCount = this.requestCounts.get(model) || 0;
    this.requestCounts.set(model, currentCount + 1);
  }

  /**
   * Create standardized Gemini error with safe type narrowing
   */
  private createGeminiError(statusCode: number, errorData: unknown): GeminiError {
    const retryableCodes = [429, 500, 502, 503, 504];

    let errorMessage = 'Unknown Gemini API error';
    let details: string | undefined;

    // Use type guard to safely validate error structure
    if (isGeminiErrorResponse(errorData)) {
      const obj = errorData as Record<string, unknown>;

      // Extract error message safely
      if (typeof obj.error === 'string') {
        errorMessage = obj.error;
      } else if (typeof obj.error === 'object' && obj.error !== null) {
        const err = obj.error as Record<string, unknown>;
        if (typeof err.message === 'string') {
          errorMessage = err.message;
        }
        if (typeof err.details === 'string') {
          details = err.details;
        }
      }
    }

    return {
      error: errorMessage,
      code: statusCode,
      details,
      retryable: retryableCodes.includes(statusCode)
    };
  }

  /**
   * Estimate tokens for text (approximation)
   */
  private estimateTokens(text: string): number {
    // Approximation: 1 token ‚âà 4 characters for Portuguese
    return Math.ceil(text.length / 4);
  }

  /**
   * Get model information
   */
  getModelInfo(model: ModelTier) {
    return {
      name: this.modelMappings[model],
      rateLimit: this.rateLimits[model],
      tier: model
    };
  }

  /**
   * Test API connectivity
   */
  async testConnection(): Promise<{ success: boolean; model: string; latency: number }> {
    const startTime = Date.now();

    try {
      const response = await this.generateContent(
        'Teste de conectividade. Responda apenas: "OK"',
        {
          model: ModelTier.LITE,
          maxTokens: 10,
          temperature: 0
        }
      );

      const latency = Date.now() - startTime;

      return {
        success: true,
        model: response.model,
        latency
      };
    } catch (_error) {
      return {
        success: false,
        model: 'unknown',
        latency: Date.now() - startTime
      };
    }
  }

  /**
   * Get current rate limit status
   */
  getRateLimitStatus(): Record<ModelTier, { current: number; limit: number; resetIn: number }> {
    const currentTime = Date.now();

    return Object.values(ModelTier).reduce((acc, model) => {
      const resetTime = this.resetTimes.get(model) || 0;
      const current = this.requestCounts.get(model) || 0;
      const limit = this.rateLimits[model];
      const resetIn = Math.max(0, resetTime - currentTime);

      acc[model] = { current, limit, resetIn };
      return acc;
    }, {} as Record<ModelTier, { current: number; limit: number; resetIn: number }>);
  }
}

/**
 * Create singleton Gemini client instance
 */
let geminiClientInstance: GeminiClient | null = null;

export function getGeminiClient(): GeminiClient {
  if (!geminiClientInstance) {
    const apiKey = process.env.GOOGLE_API_KEY;
    if (!apiKey) {
      throw new Error('GOOGLE_API_KEY environment variable is required');
    }
    geminiClientInstance = new GeminiClient(apiKey);
  }
  return geminiClientInstance;
}

/**
 * Helper function to format Gemini errors for API responses with safe type narrowing
 */
export function formatGeminiError(error: unknown): { message: string; code: number; retryable: boolean } {
  // Check if error is a GeminiError instance
  if (typeof error === 'object' && error !== null) {
    const obj = error as Record<string, unknown>;

    // Validate GeminiError structure: must have code and error fields
    if (typeof obj.code === 'number' && typeof obj.error === 'string') {
      return {
        message: obj.error,
        code: obj.code,
        retryable: obj.retryable === true
      };
    }
  }

  // Fallback: extract message safely from any error
  const messageStr = getErrorMessage(error);
  return {
    message: messageStr,
    code: 500,
    retryable: false
  };
}