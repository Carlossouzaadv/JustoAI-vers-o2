generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Workspace {
  id                     String                  @id @default(cuid())
  name                   String
  slug                   String                  @unique
  description            String?
  logoUrl                String?
  plan                   Plan                    @default(FREE)
  status                 Status                  @default(ACTIVE)
  settings               Json?
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  trialEndsAt            DateTime?
  stripeCustomerId       String?                 @unique @map("stripe_customer_id")
  stripeSubscriptionId   String?                 @unique @map("stripe_subscription_id")
  stripePriceId          String?                 @map("stripe_price_id")
  stripeCurrentPeriodEnd DateTime?               @map("stripe_current_period_end")
  processCount           Int                     @default(0) @map("process_count")
  processLimit           Int?                    @map("process_limit")
  isInGracePeriod        Boolean                 @default(false) @map("is_in_grace_period")
  gracePeriodStartedAt   DateTime?               @map("grace_period_started_at") @db.Timestamp(6)
  gracePeriodEndsAt      DateTime?               @map("grace_period_ends_at") @db.Timestamp(6)
  gracePeriodReason      String?                 @map("grace_period_reason")
  aiCache                AiCache[]
  analysis_jobs          AnalysisJob[]
  analysisVersions       CaseAnalysisVersion[]
  cases                  Case[]
  chatSessions           ChatSession[]           @relation("ChatSessions")
  clients                Client[]
  creditAllocations      CreditAllocation[]
  creditTransactions     CreditTransaction[]
  globalLogs             GlobalLog[]
  job_executions         JobExecution[]
  monitoredProcesses     MonitoredProcess[]
  processBatchUploads    ProcessBatchUpload[]
  providerTelemetry      ProviderTelemetry[]
  reportCache            ReportCache[]
  reportCustomizations   ReportCustomization[]
  reportExecutions       ReportExecution[]
  reportSchedules        ReportSchedule[]
  reportTemplates        ReportTemplate[]
  creditHolds            ScheduledCreditHold[]
  systemImports          SystemImport[]
  mappingTemplates       SystemMappingTemplate[]
  systemSyncs            SystemSync[]
  upload_batch           UploadBatch[]
  usageEvents            UsageEvent[]
  users                  UserWorkspace[]
  webhook_deliveries     WebhookDelivery[]
  credits                WorkspaceCredits?
  limitAlerts            WorkspaceLimitAlert[]
  workspace_quota_policy workspace_quota_policy?
  quota                  WorkspaceQuota?
  workspace_usage_daily  workspace_usage_daily[]

  @@index([createdAt(sort: Desc)], map: "workspaces_created_at_idx")
  @@index([status])
  @@map("workspaces")
}

model User {
  id                              String            @id @default(cuid())
  email                           String            @unique
  name                            String?
  avatar                          String?
  role                            Role              @default(USER)
  status                          Status            @default(ACTIVE)
  settings                        Json?
  supabaseId                      String            @unique
  emailVerified                   Boolean           @default(false)
  createdAt                       DateTime          @default(now())
  updatedAt                       DateTime          @updatedAt
  lastLoginAt                     DateTime?
  phone                           String?
  emailVerificationToken          String?           @db.VarChar(256)
  emailVerificationTokenExpiresAt DateTime?
  passwordResetToken              String?           @db.VarChar(256)
  passwordResetTokenExpiresAt     DateTime?
  mainGoals                       String[]          @default([])
  onboardingCompleted             Boolean           @default(false)
  onboardingCompletedAt           DateTime?
  practiceAreas                   String[]          @default([])
  image                           String?
  plan                            Plan?             @default(FREE)
  subscriptionStatus              String?
  caseEvents                      CaseEvent[]
  assignedCases                   Case[]            @relation("CaseAssignedTo")
  createdCases                    Case[]            @relation("CaseCreatedBy")
  chatSessions                    ChatSession[]     @relation("ChatSessions")
  createdShareLinks               ClientShareLink[]
  passwordReset                   PasswordReset?
  workspaces                      UserWorkspace[]

  @@index([supabaseId], map: "idx_users_supabase_id")
  @@index([createdAt(sort: Desc)], map: "users_created_at_idx")
  @@index([email])
  @@index([lastLoginAt(sort: Desc)], map: "users_last_login_idx")
  @@index([phone])
  @@map("users")
}

model UserWorkspace {
  id          String        @id @default(cuid())
  userId      String
  workspaceId String
  role        WorkspaceRole @default(MEMBER)
  status      Status        @default(ACTIVE)
  permissions Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId])
  @@index([userId, workspaceId], map: "user_workspaces_user_workspace_idx")
  @@index([workspaceId, role], map: "users_workspace_role_idx")
  @@map("user_workspaces")
}

model Client {
  id                String             @id @default(cuid())
  workspaceId       String
  name              String
  email             String?
  phone             String?
  document          String?
  type              ClientType         @default(INDIVIDUAL)
  status            Status             @default(ACTIVE)
  address           String?
  city              String?
  state             String?
  zipCode           String?
  country           String?            @default("BR")
  notes             String?
  metadata          Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  cases             Case[]
  shareLinks        ClientShareLink[]
  workspace         Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  importedDataItems ImportedDataItem[] @relation("ImportedDataItemClient")

  @@index([createdAt(sort: Desc)], map: "clients_created_at_idx")
  @@index([email])
  @@index([name])
  @@index([workspaceId, createdAt(sort: Desc)], map: "clients_workspace_created_idx")
  @@index([workspaceId], map: "clients_workspace_idx")
  @@index([workspaceId, name], map: "clients_workspace_name_idx")
  @@map("clients")
}

model Case {
  id                     String                   @id @default(cuid())
  workspaceId            String
  clientId               String
  number                 String
  title                  String
  description            String?
  type                   CaseType                 @default(CIVIL)
  status                 CaseStatus               @default(ACTIVE)
  priority               Priority                 @default(MEDIUM)
  createdById            String
  assignedToId           String?
  claimValue             Decimal?                 @db.Decimal(15, 2)
  fee                    Decimal?                 @db.Decimal(15, 2)
  feeType                FeeType                  @default(FIXED)
  filingDate             DateTime?
  dueDate                DateTime?
  closedAt               DateTime?
  tags                   String[]
  metadata               Json?
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  processoId             String?
  previewSnapshot        Json?                    @map("preview_snapshot")
  detectedCnj            String?                  @map("detected_cnj") @db.VarChar(255)
  firstPageText          String?                  @map("first_page_text")
  onboardingStatus       ProcessOnboardingStatus? @default(created) @map("onboarding_status")
  enrichmentStartedAt    DateTime?                @map("enrichment_started_at") @db.Timestamp(6)
  enrichmentCompletedAt  DateTime?                @map("enrichment_completed_at") @db.Timestamp(6)
  previewGeneratedAt     DateTime?                @map("preview_generated_at") @db.Timestamp(6)
  monitoringFrequency    MonitoringFrequency      @default(DIARIA) @map("monitoring_frequency")
  frequencySuggestedBy   String?                  @default("AI") @map("frequency_suggested_by")
  frequencyReason        String?                  @map("frequency_reason")
  frequencyChangedAt     DateTime?                @map("frequency_changed_at") @db.Timestamp(6)
  frequencyChangedBy     String?                  @map("frequency_changed_by")
  lastMonitoredAt        DateTime?                @map("last_monitored_at") @db.Timestamp(6)
  nextMonitorAt          DateTime?                @map("next_monitor_at") @db.Timestamp(6)
  monitoringPaused       Boolean                  @default(false) @map("monitoring_paused")
  aiRiskScore            Int?                     @map("ai_risk_score")
  analysisVersions       CaseAnalysisVersion[]
  documents              CaseDocument[]
  events                 CaseEvent[]
  assignedTo             User?                    @relation("CaseAssignedTo", fields: [assignedToId], references: [id])
  client                 Client                   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  createdBy              User                     @relation("CaseCreatedBy", fields: [createdById], references: [id])
  processo               Processo?                @relation(fields: [processoId], references: [id])
  workspace              Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  importedDataItems      ImportedDataItem[]       @relation("ImportedDataItemCase")
  monitoredProcesses     MonitoredProcess[]
  monitoringFrequencyLog MonitoringFrequencyLog[]
  timelineEntries        ProcessTimelineEntry[]
  providerRequests       ProviderRequest[]        @relation("ProviderRequestCase")

  @@unique([number, workspaceId])
  @@index([clientId], map: "cases_client_idx")
  @@index([clientId, status], map: "cases_client_status_idx")
  @@index([clientId, updatedAt(sort: Desc)], map: "cases_client_updated_at_idx")
  @@index([createdAt(sort: Desc)], map: "cases_created_at_idx")
  @@index([priority])
  @@index([status])
  @@index([updatedAt(sort: Desc)], map: "cases_updated_at_idx")
  @@index([workspaceId], map: "cases_workspace_idx")
  @@index([workspaceId, priority, status], map: "cases_workspace_priority_status_idx")
  @@index([workspaceId, status], map: "cases_workspace_status_idx")
  @@index([onboardingStatus], map: "idx_cases_onboarding_status")
  @@index([monitoringFrequency], map: "idx_cases_monitoring_frequency")
  @@index([lastMonitoredAt], map: "idx_cases_last_monitored_at")
  @@map("cases")
}

model CaseEvent {
  id                String             @id @default(cuid())
  caseId            String
  userId            String
  type              EventType          @default(NOTE)
  title             String
  description       String?
  metadata          Json?
  createdAt         DateTime           @default(now())
  eventDate         DateTime           @default(now())
  case              Case               @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user              User               @relation(fields: [userId], references: [id])
  importedDataItems ImportedDataItem[]

  @@index([caseId, eventDate(sort: Desc)], map: "case_events_case_date_idx")
  @@index([caseId], map: "case_events_case_idx")
  @@index([eventDate(sort: Desc)], map: "case_events_date_idx")
  @@index([type])
  @@map("case_events")
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model CaseDocument {
  id                 String                 @id @default(cuid())
  caseId             String
  name               String
  originalName       String
  type               DocumentType           @default(OTHER)
  mimeType           String
  size               Int
  url                String
  path               String
  pages              Int?
  extractedText      String?
  summary            String?
  tags               String[]
  processed          Boolean                @default(false)
  ocrStatus          ProcessStatus          @default(PENDING)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  textSha            String?
  isDuplicate        Boolean                @default(false)
  originalDocumentId String?
  cleanText          String?
  textExtractedAt    DateTime?              @db.Timestamp(6)
  analysisVersion    String?
  analysisKey        String?
  workerId           String?
  costEstimate       Float?
  juditAttachmentUrl String?                @map("judit_attachment_url") @db.VarChar(500)
  sourceOrigin       String?                @default("USER_UPLOAD") @map("source_origin") @db.VarChar(50)
  documentDate       DateTime?              @map("document_date") @db.Timestamp(6)
  metadata           Json?
  case               Case                   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  originalDocument   CaseDocument?          @relation("DocumentDuplicate", fields: [originalDocumentId], references: [id], onUpdate: NoAction)
  duplicates         CaseDocument[]         @relation("DocumentDuplicate")
  importedDataItems  ImportedDataItem[]     @relation("ImportedDataItemDocument")
  timelineEntries    ProcessTimelineEntry[] @relation("TimelineLinkedDocuments")

  @@index([textSha])
  @@index([analysisKey])
  @@index([analysisVersion])
  @@index([caseId], map: "case_documents_case_idx")
  @@index([caseId, type], map: "case_documents_case_type_idx")
  @@index([caseId, createdAt(sort: Desc)], map: "case_documents_case_uploaded_idx")
  @@index([costEstimate])
  @@index([isDuplicate])
  @@index([originalDocumentId])
  @@index([ocrStatus], map: "case_documents_status_idx")
  @@index([textExtractedAt])
  @@index([textSha, isDuplicate])
  @@index([type])
  @@index([createdAt(sort: Desc)], map: "case_documents_uploaded_at_idx")
  @@index([workerId])
  @@index([documentDate], map: "idx_case_documents_document_date")
  @@index([sourceOrigin], map: "idx_case_documents_source_origin")
  @@map("case_documents")
}

model CaseAnalysisVersion {
  id             String        @id @default(cuid())
  caseId         String
  version        Int
  status         ProcessStatus @default(COMPLETED)
  error          String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  analysisType   String        @default("GENERAL")
  confidence     Float         @default(0.85)
  costEstimate   Float         @default(0.0)
  extractedData  Json?
  metadata       Json?
  modelUsed      String        @default("gemini-1.5-flash")
  processingTime Int           @default(0)
  workspaceId    String
  analysisKey    String?       @db.VarChar(64)
  aiAnalysis     String?
  jobs           AnalysisJob[]
  case           Case          @relation(fields: [caseId], references: [id], onDelete: Cascade)
  workspace      Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([caseId, version])
  @@index([analysisKey])
  @@index([caseId], map: "case_analysis_case_idx")
  @@index([caseId, version(sort: Desc)], map: "case_analysis_case_version_idx")
  @@index([createdAt(sort: Desc)], map: "case_analysis_created_at_idx")
  @@index([version], map: "case_analysis_version_idx")
  @@index([workspaceId])
  @@map("case_analysis_versions")
}

model ProcessTimelineEntry {
  id                  String                 @id @default(cuid()) @db.VarChar(255)
  caseId              String                 @map("case_id") @db.VarChar(255)
  contentHash         String                 @map("content_hash") @db.VarChar(255)
  eventDate           DateTime               @map("event_date") @db.Timestamp(6)
  eventType           String                 @map("event_type") @db.VarChar(255)
  description         String
  normalizedContent   String                 @map("normalized_content")
  source              TimelineSource
  sourceId            String?                @map("source_id") @db.VarChar(255)
  metadata            Json?
  confidence          Float                  @default(1.0)
  createdAt           DateTime               @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt           DateTime               @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)
  contributingSources TimelineSource[]       @default([]) @map("contributing_sources")
  baseEventId         String?                @map("base_event_id")
  enrichedByIds       String[]               @default([]) @map("enriched_by_ids")
  relationType        EventRelationType?     @map("relation_type")
  originalTexts       Json?                  @map("original_texts")
  linkedDocumentIds   String[]               @default([]) @map("linked_document_ids")
  isEnriched          Boolean                @default(false) @map("is_enriched")
  enrichedAt          DateTime?              @map("enriched_at")
  enrichmentModel     String?                @map("enrichment_model") @db.VarChar(255)
  hasConflict         Boolean                @default(false) @map("has_conflict")
  conflictDetails     Json?                  @map("conflict_details")
  reviewedBy          String?                @map("reviewed_by")
  reviewedAt          DateTime?              @map("reviewed_at")
  case                Case                   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_process_timeline_entries_case")
  baseEvent           ProcessTimelineEntry?  @relation("EventEnrichment", fields: [baseEventId], references: [id])
  enrichingEvents     ProcessTimelineEntry[] @relation("EventEnrichment")
  linkedDocuments     CaseDocument[]         @relation("TimelineLinkedDocuments")

  @@unique([caseId, contentHash], map: "unique_process_timeline_entries_dedup")
  @@index([baseEventId])
  @@index([isEnriched])
  @@index([hasConflict])
  @@index([caseId], map: "idx_process_timeline_entries_case_id")
  @@index([createdAt], map: "idx_process_timeline_entries_created_at")
  @@index([eventDate], map: "idx_process_timeline_entries_event_date")
  @@index([source], map: "idx_process_timeline_entries_source")
  @@index([enrichedAt])
  @@map("process_timeline_entries")
}

model ReportSchedule {
  id                   String            @id @default(cuid())
  workspaceId          String
  name                 String
  description          String?
  type                 ReportType        @default(CASE_SUMMARY)
  frequency            Frequency         @default(WEEKLY)
  dayOfWeek            Int?
  dayOfMonth           Int?
  time                 String?
  timezone             String?           @default("America/Sao_Paulo")
  filters              Json?
  recipients           String[]
  enabled              Boolean           @default(true)
  lastRun              DateTime?
  nextRun              DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  audienceType         AudienceType?     @default(CLIENTE)
  outputFormats        OutputFormat[]    @default([PDF])
  processesLimit       Int?              @default(100)
  processIds           String[]          @default([])
  distributionHash     Int?
  executionWindowStart String?           @default("23:00")
  executionWindowEnd   String?           @default("04:00")
  monthlyQuotaUsed     Int?              @default(0)
  lastQuotaReset       DateTime?         @default(now()) @db.Timestamp(6)
  executions           ReportExecution[]
  workspace            Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([nextRun, enabled], map: "idx_report_schedules_next_run")
  @@index([workspaceId, type], map: "idx_report_schedules_workspace_type")
  @@index([enabled], map: "report_schedules_active_idx")
  @@index([frequency])
  @@index([nextRun], map: "report_schedules_next_execution_idx")
  @@index([workspaceId], map: "report_schedules_workspace_idx")
  @@map("report_schedules")
}

model AiCache {
  id          String    @id @default(cuid())
  workspaceId String
  cacheKey    String
  type        CacheType @default(ANALYSIS)
  prompt      String
  parameters  Json?
  result      Json
  model       String
  tokens      Int?
  cost        Decimal?  @db.Decimal(10, 4)
  hits        Int       @default(0)
  lastUsed    DateTime  @default(now())
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, cacheKey])
  @@index([expiresAt])
  @@index([createdAt(sort: Desc)], map: "ai_cache_created_at_idx")
  @@index([expiresAt], map: "ai_cache_expires_at_idx")
  @@index([cacheKey], map: "ai_cache_key_idx")
  @@index([type])
  @@index([workspaceId], map: "ai_cache_workspace_idx")
  @@index([workspaceId, type, cacheKey], map: "ai_cache_workspace_type_key_idx")
  @@map("ai_cache")
}

model MonitoredProcess {
  id               String            @id @default(cuid())
  workspaceId      String
  caseId           String?
  processNumber    String
  court            String
  clientName       String
  processData      Json?
  monitoringStatus MonitoringStatus  @default(ACTIVE)
  lastSync         DateTime?
  syncFrequency    SyncFrequency     @default(DAILY)
  alertsEnabled    Boolean           @default(true)
  alertRecipients  String[]
  source           ProcessSource     @default(JUDIT_API)
  extractionMethod ExtractionMethod  @default(API)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  case             Case?             @relation(fields: [caseId], references: [id])
  workspace        Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  alerts           ProcessAlert[]
  movements        ProcessMovement[]
  syncLogs         ProcessSyncLog[]

  @@unique([workspaceId, processNumber])
  @@index([court])
  @@index([lastSync(sort: Desc)], map: "monitored_processes_last_sync_idx")
  @@index([processNumber], map: "monitored_processes_number_idx")
  @@index([monitoringStatus], map: "monitored_processes_status_idx")
  @@index([workspaceId], map: "monitored_processes_workspace_idx")
  @@map("monitored_processes")
}

model ProcessMovement {
  id                 String           @id @default(cuid())
  monitoredProcessId String
  date               DateTime
  type               String
  description        String
  category           MovementCategory @default(OTHER)
  importance         Priority         @default(MEDIUM)
  requiresAction     Boolean          @default(false)
  deadline           DateTime?
  rawData            Json?
  aiSummary          String?
  aiTags             String[]
  read               Boolean          @default(false)
  archived           Boolean          @default(false)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  alerts             ProcessAlert[]
  monitoredProcess   MonitoredProcess @relation(fields: [monitoredProcessId], references: [id], onDelete: Cascade)

  @@index([date(sort: Desc)])
  @@index([monitoredProcessId, date(sort: Desc)], map: "process_movements_process_date_idx")
  @@index([monitoredProcessId, date(sort: Desc), type], map: "process_movements_process_date_type_idx")
  @@index([monitoredProcessId], map: "process_movements_process_idx")
  @@index([type])
  @@map("process_movements")
}

model ProcessAlert {
  id                 String           @id @default(cuid())
  monitoredProcessId String
  movementId         String?
  title              String
  message            String
  type               AlertType        @default(MOVEMENT)
  severity           Priority         @default(MEDIUM)
  sent               Boolean          @default(false)
  sentAt             DateTime?
  read               Boolean          @default(false)
  readAt             DateTime?
  recipients         String[]
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  monitoredProcess   MonitoredProcess @relation(fields: [monitoredProcessId], references: [id], onDelete: Cascade)
  movement           ProcessMovement? @relation(fields: [movementId], references: [id])

  @@index([monitoredProcessId, read], map: "idx_process_alerts_monitored_process_read")
  @@index([createdAt(sort: Desc)], map: "process_alerts_created_at_idx")
  @@index([monitoredProcessId], map: "process_alerts_process_idx")
  @@index([severity])
  @@index([type])
  @@map("process_alerts")
}

model ProcessSyncLog {
  id                 String           @id @default(cuid())
  monitoredProcessId String
  syncType           SyncType         @default(FULL)
  status             SyncStatus       @default(SUCCESS)
  newMovements       Int              @default(0)
  updatedMovements   Int              @default(0)
  errors             String[]
  duration           Int              @default(0)
  apiSource          ProcessSource    @default(JUDIT_API)
  startedAt          DateTime
  finishedAt         DateTime?
  monitoredProcess   MonitoredProcess @relation(fields: [monitoredProcessId], references: [id], onDelete: Cascade)

  @@map("process_sync_logs")
}

model ProcessBatchUpload {
  id          String      @id @default(cuid())
  workspaceId String
  fileName    String
  filePath    String
  fileSize    Int
  status      BatchStatus @default(PROCESSING)
  totalRows   Int         @default(0)
  processed   Int         @default(0)
  successful  Int         @default(0)
  failed      Int         @default(0)
  errors      Json?
  summary     Json?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  workspace   Workspace   @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("process_batch_uploads")
}

model SystemImport {
  id                String             @id @default(cuid())
  workspaceId       String
  fileName          String
  filePath          String
  fileSize          Int
  originalHash      String
  sourceSystem      SourceSystem       @default(UNKNOWN)
  systemVersion     String?
  detectedFormat    String?
  status            ImportStatus       @default(ANALYZING)
  progress          Int                @default(0)
  columnMapping     Json?
  dataPreview       Json?
  validation        Json?
  totalRows         Int                @default(0)
  processedRows     Int                @default(0)
  successfulRows    Int                @default(0)
  failedRows        Int                @default(0)
  skippedRows       Int                @default(0)
  importedCases     Int                @default(0)
  importedClients   Int                @default(0)
  importedEvents    Int                @default(0)
  importedDocuments Int                @default(0)
  errors            Json?
  warnings          Json?
  summary           Json?
  importSettings    Json?
  overwriteData     Boolean            @default(false)
  startedAt         DateTime           @default(now())
  finishedAt        DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  importedItems     ImportedDataItem[]
  workspace         Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([createdAt(sort: Desc)], map: "system_imports_created_at_idx")
  @@index([sourceSystem], map: "system_imports_source_idx")
  @@index([status])
  @@index([workspaceId], map: "system_imports_workspace_idx")
  @@map("system_imports")
}

model ImportedDataItem {
  id               String           @id @default(cuid())
  systemImportId   String
  originalId       String?
  dataType         ImportedDataType
  status           ImportItemStatus @default(IMPORTED)
  originalData     Json
  mappedData       Json?
  caseId           String?
  clientId         String?
  eventId          String?
  documentId       String?
  lineNumber       Int
  importOrder      Int
  validationErrors Json?
  warnings         Json?
  importedAt       DateTime         @default(now())
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  case             Case?            @relation("ImportedDataItemCase", fields: [caseId], references: [id])
  client           Client?          @relation("ImportedDataItemClient", fields: [clientId], references: [id])
  document         CaseDocument?    @relation("ImportedDataItemDocument", fields: [documentId], references: [id])
  event            CaseEvent?       @relation(fields: [eventId], references: [id])
  systemImport     SystemImport     @relation(fields: [systemImportId], references: [id], onDelete: Cascade)

  @@index([systemImportId], map: "imported_data_items_import_idx")
  @@index([status])
  @@index([dataType], map: "imported_data_items_type_idx")
  @@map("imported_data_items")
}

model SystemMappingTemplate {
  id             String       @id @default(cuid())
  workspaceId    String
  name           String
  description    String?
  sourceSystem   SourceSystem
  version        String       @default("1.0")
  columnMappings Json
  fieldMappings  Json
  transformRules Json?
  isDefault      Boolean      @default(false)
  isActive       Boolean      @default(true)
  usageCount     Int          @default(0)
  lastUsedAt     DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  workspace      Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, name])
  @@map("system_mapping_templates")
}

model SystemSync {
  id              String          @id @default(cuid())
  workspaceId     String
  sourceSystem    SourceSystem
  syncType        SyncType        @default(FULL)
  syncMode        SyncMode        @default(IMPORT_ONLY)
  schedule        SyncSchedule    @default(MANUAL)
  lastSync        DateTime?
  nextSync        DateTime?
  isActive        Boolean         @default(true)
  currentStatus   SyncStatus      @default(SUCCESS)
  syncSettings    Json?
  filterCriteria  Json?
  totalSyncs      Int             @default(0)
  successfulSyncs Int             @default(0)
  failedSyncs     Int             @default(0)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  syncLogs        SystemSyncLog[]
  workspace       Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("system_syncs")
}

model SystemSyncLog {
  id           String     @id @default(cuid())
  systemSyncId String
  syncType     SyncType   @default(FULL)
  status       SyncStatus @default(SUCCESS)
  itemsChecked Int        @default(0)
  itemsCreated Int        @default(0)
  itemsUpdated Int        @default(0)
  itemsSkipped Int        @default(0)
  itemsFailed  Int        @default(0)
  duration     Int        @default(0)
  errors       Json?
  summary      Json?
  startedAt    DateTime
  finishedAt   DateTime?
  createdAt    DateTime   @default(now())
  systemSync   SystemSync @relation(fields: [systemSyncId], references: [id], onDelete: Cascade)

  @@map("system_sync_logs")
}

model ReportCustomization {
  id                 String    @id @default(cuid())
  workspaceId        String
  profileName        String
  isDefault          Boolean   @default(false)
  companyName        String
  companyAddress     String?
  companyPhone       String?
  companyEmail       String?
  companyWebsite     String?
  primaryColor       String    @default("#1E40AF")
  secondaryColor     String    @default("#64748B")
  accentColor        String    @default("#10B981")
  backgroundColor    String    @default("#FFFFFF")
  textColor          String    @default("#1F2937")
  logoUrl            String?
  logoBase64         String?
  logoWidth          Int?      @default(80)
  logoHeight         Int?      @default(60)
  logoPosition       String    @default("left")
  headerText         String?
  headerHeight       Int?      @default(60)
  showCompanyInfo    Boolean   @default(true)
  showGenerationInfo Boolean   @default(true)
  footerText         String?
  footerHeight       Int?      @default(30)
  showPageNumbers    Boolean   @default(true)
  showGeneratedBy    Boolean   @default(true)
  watermark          String?
  watermarkOpacity   Float?    @default(0.05)
  watermarkRotation  Int?      @default(-45)
  fontSize           Int       @default(12)
  fontFamily         String    @default("Segoe UI")
  lineHeight         Float     @default(1.4)
  marginTop          Int       @default(20)
  marginRight        Int       @default(15)
  marginBottom       Int       @default(20)
  marginLeft         Int       @default(15)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  workspace          Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, profileName])
  @@index([workspaceId, isDefault])
  @@map("report_customizations")
}

model ReportExecution {
  id                    String          @id @default(cuid())
  workspaceId           String
  scheduleId            String?
  reportType            ReportType      @default(CASE_SUMMARY)
  parameters            Json?
  filters               Json?
  recipients            String[]
  status                ExecutionStatus @default(RUNNING)
  result                Json?
  filePath              String?
  fileSize              Int?
  startedAt             DateTime        @default(now())
  completedAt           DateTime?
  duration              Int?
  tokensUsed            Int?            @default(0)
  estimatedCost         Decimal?        @db.Decimal(10, 4)
  error                 String?
  retryCount            Int             @default(0)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  audienceType          AudienceType?   @default(CLIENTE)
  outputFormats         OutputFormat[]  @default([PDF])
  processCount          Int?            @default(0)
  cacheKey              String?
  cacheHit              Boolean?        @default(false)
  quotaConsumed         Int?            @default(1)
  scheduledFor          DateTime?       @db.Timestamp(6)
  fileUrls              Json?           @default("{}")
  lastMovementTimestamp DateTime?       @db.Timestamp(6)
  deltaDataOnly         Boolean?        @default(false)
  schedule              ReportSchedule? @relation(fields: [scheduleId], references: [id])
  workspace             Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
  @@index([scheduleId])
  @@index([scheduledFor, status], map: "idx_report_executions_scheduled_for")
  @@map("report_executions")
}

model GlobalLog {
  id          String      @id @default(cuid())
  workspaceId String?
  level       LogLevel    @default(INFO)
  category    LogCategory @default(SYSTEM)
  message     String
  data        Json?
  userId      String?
  sessionId   String?
  ipAddress   String?
  userAgent   String?
  requestId   String?
  traceId     String?
  duration    Int?
  createdAt   DateTime    @default(now())
  workspace   Workspace?  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, level])
  @@index([category, createdAt])
  @@index([userId])
  @@map("global_logs")
}

model Processo {
  id                String              @id @default(cuid()) @db.VarChar
  numeroCnj         String              @unique @map("numero_cnj") @db.VarChar
  dadosCompletos    Json?               @map("dados_completos")
  dataOnboarding    DateTime?           @default(now()) @map("data_onboarding") @db.Timestamp(6)
  ultimaAtualizacao DateTime?           @default(now()) @updatedAt @map("ultima_atualizacao") @db.Timestamp(6)
  cases             Case[]
  monitoramento     ProviderMonitoring?
  requisicoes       ProviderRequest[]

  @@index([numeroCnj], map: "idx_numero_cnj")
  @@map("processos")
}

model ProviderRequest {
  id         String        @id(map: "judit_requests_pkey") @default(cuid()) @db.VarChar
  requestId  String        @unique(map: "judit_requests_request_id_key") @map("request_id") @db.VarChar
  status     String        @db.VarChar
  finalidade String        @db.VarChar
  processoId String        @map("processo_id") @db.VarChar
  createdAt  DateTime?     @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt  DateTime?     @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)
  caseId     String?       @map("case_id")
  provider   LegalProvider @default(JUDIT)
  case       Case?         @relation("ProviderRequestCase", fields: [caseId], references: [id], map: "judit_requests_case_id_fkey")
  processo   Processo      @relation(fields: [processoId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "judit_requests_processo_id_fkey")

  @@index([processoId, status], map: "idx_processo_status")
  @@index([requestId], map: "idx_request_id")
  @@index([provider], map: "idx_provider_request_provider")
  @@index([caseId], map: "judit_requests_case_id_idx")
  @@index([requestId, caseId], map: "judit_requests_request_id_case_id_idx")
  @@map("provider_requests")
}

model ProviderMonitoring {
  id         String        @id(map: "judit_monitoring_pkey") @default(cuid()) @db.VarChar
  trackingId String        @unique(map: "judit_monitoring_tracking_id_key") @map("tracking_id") @db.VarChar
  tipo       String        @default("UNIVERSAL") @db.VarChar
  ativo      Boolean       @default(true)
  processoId String        @unique(map: "judit_monitoring_processo_id_key") @map("processo_id") @db.VarChar
  createdAt  DateTime?     @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt  DateTime?     @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)
  provider   LegalProvider @default(JUDIT)
  processo   Processo      @relation(fields: [processoId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "judit_monitoring_processo_id_fkey")

  @@index([ativo], map: "idx_ativo")
  @@index([trackingId], map: "idx_tracking_id")
  @@index([provider], map: "idx_provider_monitoring_provider")
  @@map("provider_monitoring")
}

model WorkspaceCredits {
  id                       String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId              String    @unique @map("workspace_id")
  reportCreditsBalance     Decimal   @default(0) @map("report_credits_balance") @db.Decimal(10, 2)
  fullCreditsBalance       Decimal   @default(0) @map("full_credits_balance") @db.Decimal(10, 2)
  reportCreditsRolloverCap Decimal   @default(36) @map("report_credits_rollover_cap") @db.Decimal(10, 2)
  fullCreditsRolloverCap   Decimal   @default(50) @map("full_credits_rollover_cap") @db.Decimal(10, 2)
  createdAt                DateTime? @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt                DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)
  workspace                Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("workspace_credits")
}

model CreditAllocation {
  id                String               @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId       String               @map("workspace_id")
  type              CreditAllocationType
  amount            Decimal              @db.Decimal(10, 2)
  remainingAmount   Decimal              @map("remaining_amount") @db.Decimal(10, 2)
  expiresAt         DateTime?            @map("expires_at") @db.Timestamp(6)
  sourceDescription String?              @map("source_description")
  createdAt         DateTime?            @default(now()) @map("created_at") @db.Timestamp(6)
  workspace         Workspace            @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  transactions      CreditTransaction[]

  @@index([workspaceId, expiresAt, createdAt])
  @@index([expiresAt])
  @@map("credit_allocations")
}

model CreditTransaction {
  id             String                @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId    String                @map("workspace_id")
  allocationId   String?               @map("allocation_id")
  type           CreditTransactionType
  creditCategory CreditCategory        @map("credit_category")
  amount         Decimal               @db.Decimal(10, 2)
  reason         String
  metadata       Json?                 @default("{}")
  createdAt      DateTime              @default(now()) @map("created_at") @db.Timestamp(6)
  allocation     CreditAllocation?     @relation(fields: [allocationId], references: [id], onUpdate: NoAction)
  workspace      Workspace             @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([workspaceId, createdAt])
  @@index([allocationId])
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_credit_transactions_workspace_created")
  @@map("credit_transactions")
}

model ScheduledCreditHold {
  id                    String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId           String    @map("workspace_id")
  reportId              String    @map("report_id")
  reportCreditsReserved Decimal   @default(0) @map("report_credits_reserved") @db.Decimal(10, 2)
  fullCreditsReserved   Decimal   @default(0) @map("full_credits_reserved") @db.Decimal(10, 2)
  expiresAt             DateTime  @map("expires_at") @db.Timestamp(6)
  createdAt             DateTime? @default(now()) @map("created_at") @db.Timestamp(6)
  workspace             Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([workspaceId])
  @@index([expiresAt])
  @@map("scheduled_credit_holds")
}

model UsageEvent {
  id                String      @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId       String      @map("workspace_id")
  eventType         String      @map("event_type")
  resourceType      String      @map("resource_type")
  resourceId        String?     @map("resource_id")
  reportCreditsCost Decimal?    @default(0) @map("report_credits_cost") @db.Decimal(10, 2)
  fullCreditsCost   Decimal?    @default(0) @map("full_credits_cost") @db.Decimal(10, 2)
  status            UsageStatus @default(COMPLETED)
  metadata          Json?       @default("{}")
  createdAt         DateTime?   @default(now()) @map("created_at") @db.Timestamp(6)
  workspace         Workspace   @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([workspaceId, createdAt])
  @@index([eventType, createdAt])
  @@index([createdAt(sort: Desc)], map: "idx_usage_events_created_at")
  @@index([eventType, createdAt(sort: Desc)], map: "idx_usage_events_event_type")
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_usage_events_workspace")
  @@index([workspaceId, eventType, createdAt(sort: Desc)], map: "idx_usage_events_workspace_type_created")
  @@map("usage_events")
}

model PlanConfiguration {
  id                        String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  planName                  String    @unique @map("plan_name")
  monitorLimit              Int       @map("monitor_limit")
  reportCreditsMonth        Decimal   @map("report_credits_month") @db.Decimal(10, 2)
  fullCreditsMonth          Decimal   @map("full_credits_month") @db.Decimal(10, 2)
  firstMonthFullBonus       Decimal   @map("first_month_full_bonus") @db.Decimal(10, 2)
  firstMonthBonusExpiryDays Int       @default(90) @map("first_month_bonus_expiry_days")
  fullRolloverCap           Decimal   @map("full_rollover_cap") @db.Decimal(10, 2)
  reportRolloverCap         Decimal   @map("report_rollover_cap") @db.Decimal(10, 2)
  tier1Processes            Int       @default(5) @map("tier_1_processes")
  tier1CreditCost           Decimal   @default(0.25) @map("tier_1_credit_cost") @db.Decimal(10, 2)
  tier2Processes            Int       @default(12) @map("tier_2_processes")
  tier2CreditCost           Decimal   @default(0.5) @map("tier_2_credit_cost") @db.Decimal(10, 2)
  tier3Processes            Int       @default(25) @map("tier_3_processes")
  tier3CreditCost           Decimal   @default(1.0) @map("tier_3_credit_cost") @db.Decimal(10, 2)
  fullCreditPerBatch        Int       @default(10) @map("full_credit_per_batch")
  createdAt                 DateTime? @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt                 DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamp(6)

  @@map("plan_configurations")
}

model UploadBatch {
  id                String              @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId       String              @map("workspace_id")
  fileName          String              @map("file_name")
  filePath          String?             @map("file_path")
  fileSize          BigInt              @map("file_size")
  status            UploadBatchStatus   @default(PROCESSING)
  totalRows         Int                 @default(0) @map("total_rows")
  processed         Int                 @default(0)
  successful        Int                 @default(0)
  failed            Int                 @default(0)
  errors            Json?               @default("[]")
  summary           Json?               @default("{}")
  config            Json?               @default("{}")
  createdAt         DateTime?           @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt         DateTime?           @default(now()) @map("updated_at") @db.Timestamp(6)
  providerTelemetry ProviderTelemetry[]
  workspace         Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  uploadBatchEvents UploadBatchEvent[]
  uploadBatchRows   UploadBatchRow[]

  @@index([status, createdAt(sort: Desc)], map: "idx_upload_batch_status")
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_upload_batch_workspace")
  @@map("upload_batch")
}

model UploadBatchRow {
  id           String          @id @default(dbgenerated("(gen_random_uuid())::text"))
  batchId      String          @map("batch_id")
  rowIndex     Int             @map("row_index")
  rowData      Json            @map("row_data")
  status       UploadRowStatus @default(PENDING)
  processId    String?         @map("process_id")
  errorMessage Json?           @map("error_message")
  retryCount   Int?            @default(0) @map("retry_count")
  createdAt    DateTime?       @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt    DateTime?       @default(now()) @map("updated_at") @db.Timestamp(6)
  uploadBatch  UploadBatch     @relation(fields: [batchId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([batchId, rowIndex])
  @@index([batchId, rowIndex], map: "idx_upload_batch_row_batch")
  @@index([batchId, status], map: "idx_upload_batch_row_status")
  @@map("upload_batch_row")
}

model UploadBatchEvent {
  id          String      @id @default(dbgenerated("(gen_random_uuid())::text"))
  batchId     String      @map("batch_id")
  eventType   String      @map("event_type")
  payload     Json
  createdAt   DateTime?   @default(now()) @map("created_at") @db.Timestamp(6)
  uploadBatch UploadBatch @relation(fields: [batchId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([batchId, createdAt(sort: Desc)], map: "idx_upload_batch_events_batch")
  @@index([eventType, createdAt(sort: Desc)], map: "idx_upload_batch_events_type")
  @@map("upload_batch_events")
}

model ProviderTelemetry {
  id               String        @id(map: "judit_telemetry_pkey") @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId      String        @map("workspace_id")
  batchId          String?       @map("batch_id")
  process_number   String
  tribunal         String
  success          Boolean
  response_time_ms Int?
  docs_retrieved   Int?          @default(0)
  movements_count  Int?          @default(0)
  parties_count    Int?          @default(0)
  error_code       String?
  error_message    String?
  retry_count      Int?          @default(0)
  rate_limit_hit   Boolean?      @default(false)
  created_at       DateTime?     @default(now()) @db.Timestamp(6)
  provider         LegalProvider @default(JUDIT)
  uploadBatch      UploadBatch?  @relation(fields: [batchId], references: [id], onUpdate: NoAction, map: "judit_telemetry_batch_id_fkey")
  workspace        Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "judit_telemetry_workspace_id_fkey")

  @@index([provider], map: "idx_provider_telemetry_provider")
  @@index([batchId, created_at(sort: Desc)], map: "idx_judit_telemetry_batch")
  @@index([success, created_at(sort: Desc)], map: "idx_judit_telemetry_success")
  @@index([workspaceId, created_at(sort: Desc)], map: "idx_judit_telemetry_workspace")
  @@map("provider_telemetry")
}

model AnalysisJob {
  id              String               @id @default(dbgenerated("(gen_random_uuid())::text"))
  processId       String               @map("process_id")
  workspaceId     String               @map("workspace_id")
  analysisKey     String               @map("analysis_key") @db.VarChar(64)
  status          JobStatus            @default(QUEUED)
  lockToken       String?              @map("lock_token") @db.VarChar(128)
  lockAcquiredAt  DateTime?            @map("lock_acquired_at") @db.Timestamp(6)
  lockExpiresAt   DateTime?            @map("lock_expires_at") @db.Timestamp(6)
  analysisType    AnalysisType         @map("analysis_type")
  modelHint       String?              @default("gemini-1.5-flash") @map("model_hint")
  filesMetadata   Json?                @default("[]") @map("files_metadata")
  progress        Int?                 @default(0)
  resultVersionId String?              @map("result_version_id")
  createdAt       DateTime?            @default(now()) @map("created_at") @db.Timestamp(6)
  startedAt       DateTime?            @map("started_at") @db.Timestamp(6)
  finishedAt      DateTime?            @map("finished_at") @db.Timestamp(6)
  workerId        String?              @map("worker_id")
  retryCount      Int?                 @default(0) @map("retry_count")
  metadata        Json?                @default("{}")
  analysisVersion CaseAnalysisVersion? @relation(fields: [resultVersionId], references: [id])
  workspaces      Workspace            @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([analysisKey], map: "idx_analysis_jobs_analysis_key")
  @@index([status, createdAt], map: "idx_analysis_jobs_status")
  @@index([workspaceId, createdAt(sort: Desc)], map: "idx_analysis_jobs_workspace")
  @@map("analysis_jobs")
}

model WorkspaceQuota {
  id                   String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId          String    @unique
  plan                 Plan      @default(FREE)
  reportsMonthlyLimit  Int       @default(20)
  reportProcessesLimit Int       @default(100)
  reportsUsedThisMonth Int?      @default(0)
  quotaResetDate       DateTime? @default(now()) @db.Timestamp(6)
  overrideLimits       Json?     @default("{}")
  createdAt            DateTime? @default(now()) @db.Timestamp(6)
  updatedAt            DateTime? @default(now()) @updatedAt @db.Timestamp(6)
  workspace            Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("workspace_quotas")
}

model ReportCache {
  id                    String       @id @default(dbgenerated("(gen_random_uuid())::text"))
  cacheKey              String       @unique
  workspaceId           String
  reportType            ReportType
  processIds            String[]
  audienceType          AudienceType
  lastMovementTimestamp DateTime     @db.Timestamp(6)
  cachedData            Json
  fileUrls              Json?        @default("{}")
  createdAt             DateTime?    @default(now()) @db.Timestamp(6)
  expiresAt             DateTime     @db.Timestamp(6)
  workspace             Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([expiresAt], map: "idx_report_cache_expires")
  @@index([cacheKey], map: "idx_report_cache_key")
  @@index([lastMovementTimestamp], map: "idx_report_cache_last_movement")
  @@index([workspaceId], map: "idx_report_cache_workspace")
  @@map("report_cache")
}

model ReportTemplate {
  id              String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId     String
  name            String
  description     String?
  templateType    String?   @default("DEFAULT")
  headerContent   String?
  footerContent   String?
  templateFileUrl String?
  styles          Json?     @default("{}")
  isDefault       Boolean?  @default(false)
  createdAt       DateTime? @default(now()) @db.Timestamp(6)
  updatedAt       DateTime? @default(now()) @updatedAt @db.Timestamp(6)
  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([workspaceId, name])
  @@map("report_templates")
}

model AnalysisCache {
  id                 String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  analysis_key       String    @unique @db.VarChar(64)
  result_data        Json
  model_used         String
  analysis_type      String
  process_id         String
  last_movement_date DateTime? @db.Timestamp(6)
  created_at         DateTime? @default(now()) @db.Timestamp(6)
  expires_at         DateTime? @db.Timestamp(6)
  access_count       Int?      @default(0)
  last_accessed_at   DateTime? @default(now()) @db.Timestamp(6)
  compressed         Boolean?  @default(false)
  data_size_bytes    Int?      @default(0)

  @@index([analysis_key], map: "idx_analysis_cache_key")
  @@index([process_id, created_at(sort: Desc)], map: "idx_analysis_cache_process")
  @@map("analysis_cache")
}

model ChatSession {
  id          String        @id @default(cuid())
  workspaceId String
  userId      String
  title       String?
  contextType String?
  contextId   String?
  status      String        @default("active")
  metadata    Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now()) @updatedAt
  messages    ChatMessage[]
  user        User          @relation("ChatSessions", fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  workspace   Workspace     @relation("ChatSessions", fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([workspaceId, userId])
  @@index([workspaceId, updatedAt])
  @@index([userId, updatedAt])
  @@map("chat_sessions")
}

model ChatMessage {
  id        String      @id @default(cuid())
  sessionId String
  role      String
  content   String
  tokens    Int?
  cost      Decimal?    @db.Decimal(10, 4)
  modelUsed String?
  metadata  Json?
  createdAt DateTime    @default(now())
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([sessionId, createdAt])
  @@index([role])
  @@map("chat_messages")
}

model WebhookDelivery {
  id            String                @id @default(cuid()) @db.VarChar(255)
  workspaceId   String                @db.VarChar(255)
  webhookType   String                @db.VarChar(255)
  eventType     String                @db.VarChar(255)
  processNumber String                @db.VarChar(255)
  payload       Json
  status        WebhookDeliveryStatus @default(PENDING)
  statusCode    Int?
  error         String?
  retryCount    Int                   @default(0)
  maxRetries    Int                   @default(5)
  nextRetryAt   DateTime?             @db.Timestamptz(6)
  lastAttemptAt DateTime?             @db.Timestamptz(6)
  deliveredAt   DateTime?             @db.Timestamptz(6)
  signature     String?
  createdAt     DateTime              @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime              @default(now()) @updatedAt @db.Timestamptz(6)
  workspaces    Workspace             @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_webhook_deliveries_workspace")

  @@index([nextRetryAt], map: "idx_webhook_deliveries_nextretryat")
  @@index([processNumber], map: "idx_webhook_deliveries_processnumber")
  @@index([status], map: "idx_webhook_deliveries_status")
  @@index([workspaceId], map: "idx_webhook_deliveries_workspace")
  @@map("webhook_deliveries")
}

model JobExecution {
  id          String             @id @default(cuid()) @db.VarChar(255)
  workspaceId String             @db.VarChar(255)
  jobType     String             @db.VarChar(255)
  jobId       String             @db.VarChar(255)
  status      JobExecutionStatus @default(PENDING)
  startedAt   DateTime?          @db.Timestamptz(6)
  completedAt DateTime?          @db.Timestamptz(6)
  duration    Int?
  input       Json?
  output      Json?
  error       String?
  errorStack  String?
  retryCount  Int                @default(0)
  maxRetries  Int                @default(3)
  nextRetryAt DateTime?          @db.Timestamptz(6)
  tags        String[]           @default([])
  metrics     Json?
  createdAt   DateTime           @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  workspaces  Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_job_executions_workspace")

  @@index([jobType], map: "idx_job_executions_jobtype")
  @@index([startedAt], map: "idx_job_executions_startedat")
  @@index([status], map: "idx_job_executions_status")
  @@index([workspaceId], map: "idx_job_executions_workspace")
  @@map("job_executions")
}

model SystemHealthMetric {
  id             String       @id @default(cuid()) @db.VarChar(255)
  timestamp      DateTime     @default(now()) @db.Timestamptz(6)
  component      String       @db.VarChar(255)
  status         HealthStatus @default(UNKNOWN)
  responseTimeMs Int?
  errorCount     Int          @default(0)
  lastError      String?
  metadata       Json?
  createdAt      DateTime     @default(now()) @db.Timestamptz(6)

  @@index([component], map: "idx_system_health_metrics_component")
  @@index([timestamp], map: "idx_system_health_metrics_timestamp")
  @@map("system_health_metrics")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model process_movements_tracking {
  id                 String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  process_id         String    @unique
  last_movement_date DateTime  @db.Timestamp(6)
  movements_hash     String?   @db.VarChar(64)
  movements_count    Int?      @default(0)
  created_at         DateTime? @default(now()) @db.Timestamp(6)
  updated_at         DateTime? @default(now()) @db.Timestamp(6)

  @@index([last_movement_date(sort: Desc)], map: "idx_process_movements_tracking_last_movement")
  @@index([process_id], map: "idx_process_movements_tracking_process")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model workspace_quota_policy {
  id                    Int       @id @default(autoincrement())
  workspace_id          String    @unique
  plan_id               String    @default("FREE")
  reports_monthly_limit Int       @default(10)
  processes_limit       Int       @default(100)
  full_credits_included Int       @default(5)
  soft_threshold_pct    Decimal   @default(0.80) @db.Decimal(3, 2)
  hard_threshold_pct    Decimal   @default(1.00) @db.Decimal(3, 2)
  created_at            DateTime? @default(now()) @db.Timestamp(6)
  updated_at            DateTime? @default(now()) @db.Timestamp(6)
  workspaces            Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_workspace_quota_policy")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model workspace_usage_daily {
  id                           Int       @id @default(autoincrement())
  workspace_id                 String
  date                         DateTime  @db.Date
  judit_calls_total            Int?      @default(0)
  judit_docs_retrieved         Int?      @default(0)
  ia_calls_fast                Int?      @default(0)
  ia_calls_mid                 Int?      @default(0)
  ia_calls_full                Int?      @default(0)
  reports_scheduled_generated  Int?      @default(0)
  reports_on_demand_generated  Int?      @default(0)
  reports_total_month_snapshot Int?      @default(0)
  full_credits_consumed_month  Int?      @default(0)
  billing_estimated_cost       Decimal?  @default(0.00) @db.Decimal(10, 2)
  created_at                   DateTime? @default(now()) @db.Timestamp(6)
  updated_at                   DateTime? @default(now()) @db.Timestamp(6)
  workspaces                   Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_workspace_usage_daily")

  @@unique([workspace_id, date], map: "unique_workspace_date")
  @@index([workspace_id, date(sort: Desc)], map: "idx_workspace_usage_daily_workspace_date")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model workspaces_backup_ssot_migration {
  id          String?
  name        String?
  slug        String?
  description String?
  logoUrl     String?
  plan        Plan?
  status      Status?
  settings    Json?
  createdAt   DateTime?
  updatedAt   DateTime?

  @@ignore
}

model ProviderAlert {
  id          String         @id(map: "judit_alerts_pkey") @default(cuid())
  severity    AlertSeverity  @default(MEDIUM)
  alertType   JuditAlertType @default(API_ERROR)
  title       String
  message     String
  workspaceId String?
  resolved    Boolean        @default(false)
  resolvedAt  DateTime?
  metadata    Json?
  errorCode   String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  numeroCnj   String?
  requestId   String?
  jobId       String?
  trackingId  String?
  provider    LegalProvider  @default(JUDIT)

  @@index([provider], map: "idx_provider_alert_provider")
  @@index([createdAt], map: "judit_alerts_createdAt_idx")
  @@index([resolved], map: "judit_alerts_resolved_idx")
  @@index([severity], map: "judit_alerts_severity_idx")
  @@map("provider_alerts")
}

model WebhookQueue {
  id          String             @id @default(cuid())
  workspaceId String?
  eventType   String?
  payload     Json
  status      WebhookQueueStatus @default(PENDING)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  processedAt DateTime?

  @@index([status])
  @@map("webhook_queues")
}

model WebhookError {
  id          String   @id @default(cuid())
  workspaceId String?
  webhookId   String?
  error       String
  details     Json?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@map("webhook_errors")
}

model PasswordReset {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@map("password_resets")
}

model ClientShareLink {
  id             String    @id @default(cuid())
  clientId       String
  token          String    @unique
  expiresAt      DateTime?
  accessCount    Int       @default(0)
  lastAccessedAt DateTime?
  permissions    Json?
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  createdById    String?
  tokenHash      String?   @unique
  client         Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  createdBy      User?     @relation(fields: [createdById], references: [id])

  @@index([clientId])
  @@index([token])
  @@map("client_share_links")
}

model Document {
  id        String   @id @default(cuid())
  userId    String
  name      String
  url       String
  type      String?
  size      Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("documents")
}

model JuditCostTracking {
  id                 String   @id @default(cuid())
  workspaceId        String?
  operationType      String   @map("operation_type")
  numeroCnj          String?  @map("numero_cnj")
  searchCost         Decimal  @map("search_cost") @db.Decimal(10, 2)
  attachmentsCost    Decimal  @map("attachments_cost") @db.Decimal(10, 2)
  totalCost          Decimal  @map("total_cost") @db.Decimal(10, 2)
  documentsRetrieved Int      @default(0) @map("documents_retrieved")
  movementsCount     Int      @default(0) @map("movements_count")
  apiCallsCount      Int      @default(1) @map("api_calls_count")
  durationMs         Int?     @map("duration_ms")
  requestId          String?  @map("request_id")
  trackingId         String?  @map("tracking_id")
  jobId              String?  @map("job_id")
  status             String   @default("success")
  errorMessage       String?  @map("error_message")
  createdAt          DateTime @default(now()) @map("created_at")

  @@index([workspaceId])
  @@index([createdAt])
  @@index([operationType])
  @@map("judit_cost_tracking")
}

model MonitoringFrequencyLog {
  id                String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  caseId            String   @map("case_id")
  previousFrequency String?  @map("previous_frequency")
  newFrequency      String   @map("new_frequency")
  changedBy         String   @map("changed_by")
  userId            String?  @map("user_id")
  reason            String?
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  case              Case     @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "MonitoringFrequencyLog_caseId_fkey")

  @@index([caseId, createdAt], map: "idx_monitoring_frequency_log_case_created")
  @@map("monitoring_frequency_log")
}

model WorkspaceLimitAlert {
  id           String    @id @default(dbgenerated("(gen_random_uuid())::text"))
  workspaceId  String    @map("workspace_id")
  alertType    String    @map("alert_type")
  limitType    String    @map("limit_type")
  currentValue Int       @map("current_value")
  limitValue   Int       @map("limit_value")
  wasResolved  Boolean   @default(false) @map("was_resolved")
  resolvedAt   DateTime? @map("resolved_at") @db.Timestamp(6)
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamp(6)
  workspace    Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "WorkspaceLimitAlert_workspaceId_fkey")

  @@index([workspaceId, wasResolved], map: "idx_workspace_limit_alert_resolved")
  @@map("workspace_limit_alerts")
}

enum NotificationFrequency {
  IMMEDIATE
  DAILY_DIGEST
  WEEKLY_DIGEST
  DISABLED
}

enum Plan {
  FREE
  BASIC
  PRO
  ENTERPRISE
  STARTER
  GESTAO
  PROFESSIONAL
  PERFORMANCE
  TRIAL
}

enum Status {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum Role {
  ADMIN
  USER
  VIEWER
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum ClientType {
  INDIVIDUAL
  COMPANY
  GOVERNMENT
  NGO
}

enum CaseType {
  CIVIL
  CRIMINAL
  LABOR
  FAMILY
  COMMERCIAL
  ADMINISTRATIVE
  CONSTITUTIONAL
  TAX
  OTHER
}

enum CaseStatus {
  ACTIVE
  SUSPENDED
  CLOSED
  ARCHIVED
  CANCELLED
  UNASSIGNED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum FeeType {
  FIXED
  HOURLY
  SUCCESS_FEE
  MIXED
}

enum EventType {
  NOTE
  CALL
  MEETING
  EMAIL
  DOCUMENT_RECEIVED
  DOCUMENT_SENT
  HEARING
  DEADLINE
  PAYMENT
  OTHER
  DOCUMENT_UPDATED
  DOCUMENT_DELETED
  DOCUMENT_NOTE
}

enum DocumentType {
  CONTRACT
  PETITION
  MOTION
  EVIDENCE
  CORRESPONDENCE
  COURT_ORDER
  JUDGMENT
  APPEAL
  AGREEMENT
  INVOICE
  OTHER
}

enum ProcessStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum ProcessOnboardingStatus {
  created
  previewed
  enriching
  enriched
  analysis_pending
  analyzed
}

enum AnalysisType {
  GENERAL
  RISK_ASSESSMENT
  DOCUMENT_REVIEW
  CASE_STRATEGY
  PRECEDENT_RESEARCH
  CONTRACT_ANALYSIS
  COMPLIANCE_CHECK
}

enum ReportType {
  CASE_SUMMARY
  FINANCIAL
  PRODUCTIVITY
  DEADLINE_ALERTS
  CUSTOM
  COMPLETO
  NOVIDADES
}

enum Frequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

enum CacheType {
  ANALYSIS
  DOCUMENT_SUMMARY
  PRECEDENT_SEARCH
  RISK_ASSESSMENT
  CONTRACT_REVIEW
}

enum MonitoringStatus {
  ACTIVE
  PAUSED
  STOPPED
  ERROR
}

enum SyncFrequency {
  HOURLY
  DAILY
  WEEKLY
  MANUAL
}

enum ProcessSource {
  JUDIT_API
  CODILO_API
  MANUAL_INPUT
  EXCEL_UPLOAD
}

enum ExtractionMethod {
  API
  WEB_SCRAPING
  MANUAL
}

enum MovementCategory {
  HEARING
  DECISION
  PETITION
  DOCUMENT_REQUEST
  DEADLINE
  NOTIFICATION
  APPEAL
  SETTLEMENT
  OTHER
}

enum AlertType {
  MOVEMENT
  DEADLINE
  ERROR
  SYNC_FAILURE
  IMPORTANT_DECISION
}

enum SyncType {
  FULL
  INCREMENTAL
  MANUAL
}

enum SyncStatus {
  SUCCESS
  PARTIAL_SUCCESS
  FAILED
  TIMEOUT
}

enum BatchStatus {
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum SourceSystem {
  PROJURIS
  LEGAL_ONE
  ASTREA
  CP_PRO
  SAJ
  ESAJ
  PJE
  THEMIS
  ADVBOX
  JUSBRASIL
  UNKNOWN
}

enum ImportStatus {
  ANALYZING
  MAPPING
  VALIDATING
  IMPORTING
  COMPLETED
  FAILED
  CANCELLED
  ROLLING_BACK
  ROLLED_BACK
}

enum ImportedDataType {
  CASE
  CLIENT
  EVENT
  DOCUMENT
  LAWYER
  CONTACT
  FINANCIAL
  DEADLINE
  OTHER
}

enum ImportItemStatus {
  IMPORTED
  UPDATED
  SKIPPED
  FAILED
  DUPLICATE
  ROLLED_BACK
}

enum SyncMode {
  IMPORT_ONLY
  BIDIRECTIONAL
  EXPORT_ONLY
}

enum SyncSchedule {
  MANUAL
  DAILY
  WEEKLY
  MONTHLY
  REAL_TIME
}

enum ExecutionStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  AGENDADO
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
}

enum LogCategory {
  SYSTEM
  USER_ACTION
  API_CALL
  SYNC
  REPORT
  AUTH
  UPLOAD
  ANALYSIS
  MONITORING
}

enum TimelineSource {
  DOCUMENT_UPLOAD
  API_JUDIT
  MANUAL_ENTRY
  SYSTEM_IMPORT
  AI_EXTRACTION
}

enum EventRelationType {
  DUPLICATE
  ENRICHMENT
  RELATED
  CONFLICT
}

enum CreditAllocationType {
  MONTHLY
  BONUS
  PACK
}

enum CreditTransactionType {
  DEBIT
  CREDIT
}

enum CreditCategory {
  REPORT
  FULL
}

enum UsageStatus {
  COMPLETED
  FAILED
  INSUFFICIENT_CREDITS
}

enum UploadBatchStatus {
  PROCESSING
  PAUSED
  COMPLETED
  FAILED
  CANCELLED
}

enum UploadRowStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  SKIPPED
  CANCELLED
}

enum JobStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum AudienceType {
  CLIENTE
  DIRETORIA
  USO_INTERNO
}

enum OutputFormat {
  PDF
  DOCX
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum WebhookDeliveryStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  RETRYING
  SKIPPED
}

enum WebhookQueueStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  RETRYING
  SKIPPED
}

enum JobExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  RETRYING
  CANCELLED
  TIMEOUT
}

enum WorkerJobStatus {
  PENDING
  COMPLETED
  FAILED
}

enum HealthStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
  UNKNOWN
}

enum LegalProvider {
  JUDIT
  ESCAVADOR
}

enum MonitoringFrequency {
  DIARIA
  SEMANAL
  MENSAL
}

enum JuditAlertType {
  API_ERROR
  RATE_LIMIT
  CIRCUIT_BREAKER
  HIGH_COST
  TIMEOUT
  ATTACHMENT_TRIGGER
  MONITORING_FAILED
}

enum JuditOperationType {
  ONBOARDING
  MONITORING_CHECK
  ATTACHMENT_FETCH
  MANUAL_SEARCH
}
