guia rápido

Guia Rápido
Tutorial completo para fazer sua primeira consulta na Judit API

​
Fluxo Básico
A Judit API funciona com um padrão síncrono e assíncrono:
​
Requisições com padrão assíncrono:
Criar requisição (POST /requests) - Inicia a consulta
Aguardar processamento (GET /requests) - A API busca os dados nos tribunais(Acompanhar status)
Consultar resultado (GET /responses) - Obtém os dados processados
​
Requisições com padrão síncrono:
Criar requisição (POST /lawsuits) - Inicia a consulta e já entrega a resposta
​
Pré-requisitos
API Key válida (solicite acesso conosco)
Ferramenta para fazer requisições HTTP (cURL, Postman, ou código)
​
Exemplo Completo
​
1. Configurar Variáveis de Ambiente

Copy
export JUDIT_API_KEY="sua-api-key-aqui"
export JUDIT_BASE_URL="https://requests.prod.judit.io"
​
2. Criar uma Requisição

cURL

Python

JavaScript

PHP

Go

Copy
const apiKey = process.env.JUDIT_API_KEY;
const baseUrl = process.env.JUDIT_BASE_URL;

const headers = {
    'api-key': apiKey,
    'Content-Type': 'application/json'
};

// Criar requisição
const payload = {
    search: {
        search_type: 'cpf',
        search_key: '999.999.999-99',
        cache_ttl_in_days: 7
    }
};

const response = await fetch(`${baseUrl}/requests`, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(payload)
});

const requestData = await response.json();
const requestId = requestData.request_id;

console.log(`Requisição criada: ${requestId}`);
​
3. Verificar Status da Requisição

cURL

Python

JavaScript

PHP

Go

Copy
// Verificar status
let statusResponse = await fetch(`${baseUrl}/requests/${requestId}`, {
    headers: headers
});

let statusData = await statusResponse.json();
console.log(`Status: ${statusData.status}`);

// Aguardar conclusão
while (['pending', 'processing'].includes(statusData.status)) {
    await new Promise(resolve => setTimeout(resolve, 5000)); // 5 segundos
    
    statusResponse = await fetch(`${baseUrl}/requests/${requestId}`, {
        headers: headers
    });
    statusData = await statusResponse.json();
    console.log(`Status: ${statusData.status}`);
}
​
4. Obter Resultados
Quando o status for completed, consulte os resultados:

cURL

Python

JavaScript

PHP

Go

Copy
// Obter resultados
if (statusData.status === 'completed') {
    const resultsResponse = await fetch(`${baseUrl}/responses?page=1`, {
        headers: headers
    });
    const results = await resultsResponse.json();
    
    console.log('Processos encontrados:');
    results.page_data?.forEach(item => {
        console.log(`- ${JSON.stringify(item)}`);
    });
}
​
Tipos de Consulta Disponíveis

Por CPF

Por CNPJ

Por OAB

Por CNJ

Por NOME

Copy
{
  "search": {
    "search_type": "lawsuit_cnj",
    "search_key": "9999999-99.9999.9.99.9999"
  }
}
​
Tipos de Resposta
parties: Apenas informações das partes
attachments: Lista de anexos disponíveis
step: Movimentações processuais
​
Filtros Avançados
Para consultas mais específicas por documento, é possivel utilizar filtros:

Copy
{
  "search": {
    "search_type": "cpf",
    "search_key": "999.999.999-99",
    "search_params": {
      "filter": {
        "side":"passive",
        "amount_gte": 10000,
        "distribution_date_gte": "2024-10-10T00:00:00.000Z",
        "tribunals": {
          "keys": ["TJSP", "TJRJ"],
          "not_equal": false
        }
      }
    }
  }
}
​
Boas Práticas
​
1. Use Cache Inteligente
Configure cache_ttl_in_days para evitar consultas desnecessárias: Esse campo define por quantos dias um resultado armazenado em cache será considerado válido antes de uma nova consulta ser feita.

Copy
{
  "cache_ttl_in_days": 7  // Usar cache por até 7 dias
}
​
2. Implemente Retry com Backoff

Copy
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  } // Função setTimeout auxiliar de pausa baseada em setTimeout (nativa do JavaScript)

  async function retryWithBackoff(func, maxRetries = 3) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await func();
      } catch (error) {
        if (attempt === maxRetries - 1) {
          throw error; // Última tentativa falhou, propaga o erro
        }

        // Backoff exponencial + jitter aleatório
        const waitTime = (2 ** attempt) * 1000 + Math.random() * 1000;
        console.log(
          `Tentativa ${attempt + 1} falhou. Aguardando ${waitTime.toFixed(0)}ms antes de tentar novamente...`
        );
        await sleep(waitTime);
      }
    }
  }


Validação da API Key
​
Teste de Conectividade

Copy
import requests

def test_api_key(api_key):
    """Testa se a API Key está válida"""
    headers = {'api-key': api_key}
    
    try:
        response = requests.get(
            'https://requests.prod.judit.io/requests',
            headers=headers,
            params={'page': 1, 'page_size': 1}
        )
        
        if response.status_code == 200:
            print("✅ API Key válida")
            return True
        elif response.status_code == 401:
            print("❌ API Key inválida")
            return False
        else:
            print(f"⚠️ Erro inesperado: {response.status_code}")
            return False
            
    except requests.RequestException as e:
        print(f"❌ Erro de conexão: {e}")
        return False

# Usar a função
api_key = os.getenv('JUDIT_API_KEY')
test_api_key(api_key)
​
Monitoramento de Uso

Copy
def check_api_usage(response):
    """Monitora uso da API através dos headers"""
    
    # Rate limit info
    limit = response.headers.get('X-RateLimit-Limit')
    remaining = response.headers.get('X-RateLimit-Remaining')
    reset = response.headers.get('X-RateLimit-Reset')
    
    if limit and remaining:
        usage_percent = ((int(limit) - int(remaining)) / int(limit)) * 100
        
        print(f"Uso da API: {usage_percent:.1f}%")
        print(f"Requisições restantes: {remaining}")
        
        if usage_percent > 80:
            print("⚠️ Próximo do limite de rate limit!")

Paginação & Cursor
A Judit API utiliza paginação baseada em cursor para navegar através de grandes conjuntos de dados de forma eficiente e consistente.

​
Como Funciona a Paginação
​
Parâmetros de Paginação
Parâmetro	Tipo	Padrão	Descrição
page	integer	1	Número da página (baseado em 1)
page_size	integer	20	Quantidade de itens por página (recomendamos um máximo de 100 para melhor desempenho)
​
Estrutura da Resposta

Copy
{
    
    "page": 1,             // Página atual retornada
    "page_count": 2,       // Quantidade de páginas disponíveis nesta consulta
    "all_pages_count": 10, // Total de páginas considerando todos os registros
    "all_count": 200       // Total de itens encontrados na consulta
    
}
​
Exemplos Práticos
​
Consulta Básica com Paginação

cURL

Python

JavaScript

PHP

Copy
const apiKey = process.env.JUDIT_API_KEY;
const baseUrl = "https://requests.prod.judit.io";

const headers = {
    'api-key': apiKey,
    'Content-Type': 'application/json'
};

async function getRequestsPage(page = 1, pageSize = 20) {
    const params = new URLSearchParams({
        page: page.toString(),
        page_size: pageSize.toString()
    });
    
    try {
        const response = await fetch(`${baseUrl}/requests?${params}`, {
            headers: headers
        });
        
        if (response.ok) {
            return await response.json();
        } else {
            console.error(`Erro: ${response.status}`);
            return null;
        }
    } catch (error) {
        console.error('Erro na requisição:', error);
        return null;
    }
}

// Buscar primeira página
const data = await getRequestsPage(1, 10);
console.log(`Página atual: ${data.meta.current_page}`);
console.log(`Total de itens: ${data.meta.total_items}`);
​
Paginação em Monitoramentos

Python

JavaScript

PHP

Copy
async function getTrackingPage(page = 1, status = null) {
    // Busca página de monitoramentos
    
    const params = new URLSearchParams({ page: page.toString() });
    
    if (status) {
        params.append('status', status);
    }
    
    try {
        const response = await fetch(`https://tracking.prod.judit.io/tracking?${params}`, {
            headers: headers
        });
        
        return response.ok ? await response.json() : null;
    } catch (error) {
        console.error('Erro na requisição:', error);
        return null;
    }
}

// Buscar monitoramentos ativos
const activeTracking = await getTrackingPage(1, 'active');
​
Otimizações e Boas Práticas
​
1. Tamanho de Página Otimizado

Python

JavaScript

PHP

Copy
// Para listagens rápidas
const smallPage = await getRequestsPage(1, 10);

// Para processamento em lote
const largePage = await getRequestsPage(1, 5000);
​
2. Processamento Paralelo

Python

JavaScript

PHP

Copy
async function fetchPageRange(startPage, endPage, pageSize = 50) {
    // Busca múltiplas páginas em paralelo
    
    const fetchSinglePage = (page) => getRequestsPage(page, pageSize);
    
    const pagePromises = [];
    for (let page = startPage; page <= endPage; page++) {
        pagePromises.push(
            fetchSinglePage(page)
                .then(data => ({ page, data }))
                .catch(error => {
                    console.error(`Erro na página ${page}:`, error);
                    return { page, data: null };
                })
        );
    }
    
    // Aguardar todas as requisições
    const results = await Promise.all(pagePromises);
    
    // Filtrar resultados válidos e ordenar
    return results
        .filter(result => result.data !== null)
        .sort((a, b) => a.page - b.page)
        .map(result => result.data);
}

// Buscar páginas 1-5 em paralelo
const parallelResults = await fetchPageRange(1, 5);
​
3. Controle de Rate Limit

Python

JavaScript

PHP

Copy
async function paginateWithRateLimit(endpoint, delay = 200) {
    // Paginação respeitando rate limits
    let page = 1;
    const allData: any[] = [];
    
    while (true) {
        // Fazer requisição (ajuste o getRequestsPage para receber endpoint e page)
        const data = await getRequestsPage(page, 50);

        if (!data || !data.page_data) {
            break;
        }

        allData.push(...data.page_data);

        // Verificar se ainda há páginas para percorrer
        if (page >= data.all_pages_count) {
            break;
        }

        page++;

        // Delay para respeitar rate limit
        await new Promise(resolve => setTimeout(resolve, delay));

        console.log(`Página ${page - 1} processada, total: ${allData.length} itens`);
    }

    return allData;
}

Objeto Lawsuit (Processo Judicial)
O objeto lawsuit é a estrutura de dados central que representa um processo judicial completo no sistema Judit. Este objeto contém todas as informações relevantes sobre um processo, desde dados básicos até detalhes específicos sobre partes envolvidas, andamentos e anexos.

​
Estrutura Geral
O objeto lawsuit é organizado em seções principais que agrupam informações relacionadas:
CAPA PROCESSUAL(response_data): Dados principais do processo.
PARTES (parties): Informações sobre as partes envolvidas.
ANDAMENTO (steps): Histórico de movimentações processuais.
ANEXOS (attachments): Documentos anexados ao processo.
PROCESSOS RELACIONADOS (related_lawsuits): Processos relacionados ao consultados.
​
Propriedades Principais
​
response_data
Propriedade	Tipo	Descrição
area	string	Área do direito (ex: DIREITO À EDUCAÇÃO, DIREITO ADMINISTRATIVO, DIREITO AMBIENTAL, etc.)
name	string	Descrição ou nome do processo (ex: 1 PARTE ATIVA X 1 PARTE PASSIVA)
distribution_date	string	Data de distribuição do processo
instance	string	Grau do processo (instância)
courts	string	Fórum responsável
secrecy_level	integer	Nível de sigilo (0 = público, 1 = segredo de justiça, 2 = restrito a servidores, 3 = restrito a unidade judicial, 4 = sigiloso apenas para magistrados e chefes de cartório, 5 = sigilo absoluto)
subjects	array	Assuntos do processo, de acordo com a tabela de assuntos do CNJ
classifications	array	Classes do processo, de acordo com a tabela de classes do CNJ
judge	string	Nome do juiz ou relator
code	string	Número do processo (CNJ)
justice_description	string	Tipo de justiça (ex: STF, CNJ, STJ, Justiça Federal, Justiça do Trabalho, Justiça Eleitoral, Justiça Militar da União, Justiça Estadual, Justiça Militar Estadual)
county	string	Comarca
tribunal_acronym	string	Sigla do tribunal
city	string	Cidade
state	string	Unidade Federativa (UF)
situation	string	Situação ou status do processo capturado no tribunal
phase	string	Fase do processo (ex: INICIAL, SENTENÇA, EXECUÇÃO OU CUMPRIMENTO, TRÂNSITO EM JULGADO OU EM ACORDO, RECURSO, ARQUIVADO, SUSPENSO, REATIVADO, CANCELADO)
status	string	Status do processo (ATIVO ou FINALIZADO)
amount	number	Valor da causa
​
parties
Propriedade	Tipo	Descrição
name	string	Nome da parte
main_document	string	Documento principal da parte (CPF ou CNPJ)
side	string	Polo da parte: ACTIVE, PASSIVE, INTERESTED ou UNKNOWN
person_type	string	Papel da parte no processo (ex: RÉU, AUTOR, ADVOGADO, RECORRENTE, RECORRIDO, etc.)
documents	array	Array de documentos; cada item contém document_type (ex: CPF, CNPJ, OAB) e document (número)
lawyers	array	Array de advogados vinculados à parte; se o tribunal não ligar o advogado a uma parte, ele pode aparecer no array principal de partes
​
steps
Propriedade	Tipo	Descrição
step_date	string	Data do andamento
step_type	string	Código do andamento, de acordo com a tabela de movimentos do CNJ
content	string	Conteúdo/texto do andamento
private	boolean	Indica se o andamento está sob sigilo
​
attachments
Propriedade	Tipo	Descrição
step_id	string	ID do andamento ao qual o anexo está vinculado
attachment_date	string	Data do anexo
attachment_name	string	Título do anexo
extension	string	Extensão do anexo (ex: PDF, HTML, TXT, etc.)
​
related_lawsuits
Propriedade	Tipo	Descrição
code	string	Número do processo(CNJ)
instance	string	Grau do processo

CAPA (Cover Information)
Propriedade	Tipo	Descrição
subjects	string	Assuntos do processo
classifications	string	Classes processuais
judge	string	Nome do juiz/relator
code	string	Número do processo (CNJ)
justice_description	string	Tipo de justiça
​
Tipos de Justiça
Para a lista completa dos tipos de justiça e órgãos do Poder Judiciário, consulte Enumerações do Objeto Lawsuit.
​
Informações de Localização
Propriedade	Tipo	Descrição
county	string	Comarca
tribunal_acronym	string	Sigla do tribunal
city	string	Cidade
state	string	UF (Unidade Federativa)
situation	string	Situação atual do processo
​
Status e Fase do Processo
Propriedade	Tipo	Descrição
phase	string	Fase atual (ex: FASE)
status	string	Status do processo

Informações sobre Valor da Causa
Propriedade	Tipo	Descrição
amount	string	Valor da causa
name	string	Nome da parte
main_document	string	Documento principal da parte (CPF ou CNPJ)
side	string	Polo da parte
person_type	string	Papel da parte no processo

ANDAMENTO (Steps)
Representa o histórico de movimentações do processo.
Propriedade	Tipo	Descrição
step_date	string	Data do andamento
step_type	string	Código do andamento
content	string	Conteúdo do andamento
private	boolean	Caso seja um andamento sob sigilo
step_id	string	ID do andamento

ANEXOS (Attachments)
Documentos anexados ao processo.
Propriedade	Tipo	Descrição
attachment_date	string	Data do anexo
attachment_name	string	Título do anexo
​
Exemplos de Uso
​
Estrutura do Objeto Lawsuit

Resposta da API

Copy
{
  "response_data": {
    "area": "DIREITO CIVIL",
    "name": "Ação de Cobrança",
    "distribution_date": "2024-01-15",
    "instance": "1ª INSTÂNCIA",
    "court": "1ª VARA CÍVEL",
    "secrecy_level": 0,
    "subjects": "COBRANÇA",
    "classifications": "PROCEDIMENTO COMUM",
    "judge": "João Silva Santos",
    "code": "9999999-99.9999.9.99.9999",
    "justice_description": "JUSTIÇA ESTADUAL",
    "county": "SÃO PAULO",
    "tribunal_acronym": "TJSP",
    "city": "SÃO PAULO",
    "state": "SP",
    "situation": "ATIVO",
    "phase": "CONHECIMENTO",
    "status": "INICIAL",
    "amount": "R$ 50.000,00"
  },
  "parties": [
    {
      "name": "EMPRESA XYZ LTDA",
      "main_document": "12.345.678/0001-90",
      "side": "ATIVO",
      "person_type": "AUTOR",
      "documents": ["CNPJ"],
      "lawyers": [
        {
          "name": "Maria Advogada",
          "oab": "OAB/SP 123456"
        }
      ]
    }
  ],
  "steps": [
    {
      "step_date": "2024-01-15",
      "step_type": "DISTRIBUIÇÃO",
      "content": "Processo distribuído para a 1ª Vara Cível",
      "private": false,
      "step_id": "001"
    }
  ],
  "attachments": [
    {
      "attachment_date": "2024-01-15",
      "attachment_name": "Petição Inicial"
    }
  ]
}
​
Consumindo a API
// Configurar cliente
const apiKey = process.env.JUDIT_API_KEY;
const baseURL = 'https://api.judit.io/v1';

const headers = {
  'Authorization': `Bearer ${apiKey}`,
  'Content-Type': 'application/json'
};

// Buscar processo específico
async function getLawsuit(cnj) {
  const response = await fetch(`${baseURL}/lawsuits/${cnj}`, {
    method: 'GET',
    headers: headers
  });
  
  if (!response.ok) {
    throw new Error(`Erro: ${response.status}`);
  }
  
  const lawsuit = await response.json();
  return lawsuit;
}

// Filtrar processos
async function searchLawsuits(filters) {
  const params = new URLSearchParams(filters);
  const response = await fetch(`${baseURL}/lawsuits?${params}`, {
    method: 'GET',
    headers: headers
  });
  
  return await response.json();
}

// Exemplo de uso
const lawsuit = await getLawsuit('9999999-99.9999.9.99.9999');
console.log(`Processo: ${lawsuit.response_data.name}`);
console.log(`Status: ${lawsuit.response_data.status}`);

